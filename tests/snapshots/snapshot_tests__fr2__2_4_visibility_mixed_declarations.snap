---
source: tests/snapshot_tests.rs
expression: output
---
// FR2.4: Complex visibility grouping with mixed declaration types

export type AppAction = {
    type: 'SET_USER';
    payload: string;
} | {
    type: 'SET_LOADING';
    payload: boolean;
};

export function appReducer(state: AppState, action: AppAction): AppState {
    switch(action.type){
        case 'SET_USER':
            return {
                ...state,
                user: action.payload
            };
        case 'SET_LOADING':
            return {
                ...state,
                loading: action.payload
            };
    }
}

// Exported state management
export interface AppState {
    user: null | string;
    loading: boolean;
}

export function createPublicError(statusCode: number, message: string): PublicError {
    return new PublicError(statusCode, message);
}
export function isPublicError(error: unknown): error is PublicError {
    return error instanceof PublicError;
}
export async function fetchPublic(endpoint: string): Promise<Response> {
    return new Response();
}

export const initialAppState: AppState = {
    loading: false,
    user: null
};
export const isNumber: Validator<number> = (value): value is number =>{
    return typeof value === 'number';
};
export const isString: Validator<string> = (value): value is string =>{
    return typeof value === 'string';
};

// Exported Error class and utilities  
export class PublicError extends Error {
    constructor(public statusCode: number, message: string){
        super(message);
    }
}

// Exported validation utilities
export type Validator<T> = (value: unknown) => value is T;

// Mixed async utilities
async function fetchInternal(path: string): Promise<unknown> {
    return {};
}

// Internal Error class and utilities
class InternalError extends Error {
    constructor(public code: string){
        super(`Internal error: ${code}`);
    }
}

// Internal validation utilities
type InternalValidator<T> = (value: T) => boolean;

function isInternalError(error: unknown): error is InternalError {
    return error instanceof InternalError;
}

const isNonEmpty: InternalValidator<string> = (value)=>value.length > 0;
const isPositive: InternalValidator<number> = (value)=>value > 0;
const privateInitialState: PrivateState = {
    cache: new Map(),
    counter: 0
};

// Internal state management
interface PrivateState {
    counter: number;
    cache: Map<string, unknown>;
}
